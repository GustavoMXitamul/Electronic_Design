/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "stm32l053xx.h"

// Macros para los dígitos del display
#define cero  0x3F
#define uno   0x06
#define dos   0x5B
#define tres  0x4F
#define cuatro  0x66
#define cinco   0x6D
#define seis   0x7D
#define siete  0x07
#define ocho   0x7F
#define nueve  0x67
#define A 	   0x77
#define B 	   0x7C
#define C 	   0x39
#define D 	   0x4E
#define E 	   0x79
#define F 	   0x71

#define KEY_A_INDEX 3  // Asumiendo que "A" es el decimosexto botón
#define KEY_B_INDEX 7  // Asumiendo que "A" es el decimosexto botón
#define KEY_C_INDEX 11  // Asumiendo que "A" es el decimosexto botón
#define KEY_D_INDEX 15  // Asumiendo que "D" es el decimosexto botón
#define KEY_F_INDEX 14 //Asumiendo que F es *
#define KEY_E_INDEX 12

void delay_ms(uint16_t n);
void update_display_values(void); // Elimina el argumento aquí
uint8_t decoder(uint8_t value_to_decode);
void decimal_decoder(uint8_t value);

void USART2_write(uint8_t ch);
void USART2_putstring(uint8_t* StringPtr);
void USART2_putstring_E(uint8_t* StringPtr);
uint8_t USART2_read(void);
uint8_t mychar = 0x00;

void USART2_getstring(uint8_t* buffer, uint32_t max_size);



uint8_t first_digit_display = 0xFF; // Primer dígito para mostrar
uint8_t second_digit_display = 0xFF; // Segundo dígito para mostrar
uint8_t third_digit_display = 0xFF; // Segundo dígito para mostrar
uint8_t fourth_digit_display = 0xFF; // Segundo dígito para mostrar
uint8_t fifth_digit_display = 0xFF;
uint8_t stored_value = 0; // Variable para almacenar el valor mostrado en los displays
int product_value = 0;
int operand1, operand2;
int num1, num2, opcion;


const uint8_t key_to_display[] = {
    uno, dos, tres, A, // Columna 1: 1, 2, 3, A
    cuatro, cinco, seis, B, // Columna 2: 4, 5, 6, B
    siete, ocho, nueve, C, // Columna 3: 7, 8, 9, C
    E, cero, F, D // Columna 4: *, 0, #, D
};

uint8_t get_number_from_key(uint8_t key){
	switch (key){
		case 0: return 1;
		case 1: return 2;
		case 2: return 3;
		case 4: return 4;
		case 5: return 5;
		case 6: return 6;
		case 8: return 7;
		case 9: return 8;
		case 10: return 9;
		case 13: return 0;
		default: return 0;
	}
}

uint8_t get_key_from_number(uint8_t number){
	switch (number){
		case 1: return 0;
		case 2: return 1;
		case 3: return 2;
		case 4: return 4;
		case 5: return 5;
		case 6: return 6;
		case 7: return 8;
		case 8: return 9;
		case 9: return 10;
		case 0: return 13;
		default: return 13;
	}
}

int main(void)
{

    // Habilitar el reloj para GPIOC y GPIOB
    RCC->IOPENR |= (1 << 2) | (1 << 1) | (1 << 0);


	//Enable HSI 16MHz
		//HSI on
	RCC->CR |= (1<<0);
		//HSI16 as SYSCLK
	RCC->CFGR |= (1<<0);


	//Enable CLK
		//For the Peripherals under use via RCC reg
		//PORTA
	RCC->IOPENR |= 1<<0;


	//USART 2 pin configuration
		//Alternate Function MODE for PA2 and PA3
	GPIOA->MODER &= ~(1<<4);//PA2 as AF, MODER [10]
	GPIOA->MODER &= ~(1<<6);//PA3 as AF, MODER [10]
		//Select which MODER, AF4 for USART2, TX on PA2 :: RX on PA3
	GPIOA->AFR[0] |= 1<<10; //PA2 mapped as AF4
	GPIOA->AFR[0] |= 1<<14; //PA3 mapped as AF4

	//USART2 peripheral configuration
		//USART2 clock enable on RCC APB1ENR register
	RCC->APB1ENR |= 1<<17;
		//Baud Rate calculation @9600 with 16Mhz
	USART2->BRR = 1667;
		//Enable TX and RX
	USART2->CR1 |= (1<<2)|(1<<3);
		//Enable Peripheral
	USART2->CR1 |= 1<<0;




    // Configurar los pines de GPIOC como salida para los displays (asumiendo que esto ya está hecho correctamente)
    uint32_t portC_masks = (0b01 << 8) | (0b01 << 10) | (0b01 << 12) | (0b01 << 14) | (0b01 << 16) | (0b01 << 18);
    GPIOC->MODER &= ~(0b11 << 8 | 0b11 << 10 | 0b11 << 12 | 0b11 << 14 | 0b11 << 16 | 0b11 << 18);
    GPIOC->MODER |= portC_masks;



    // Configurar los pines de GPIOB como salida para los segmentos de los displays
    GPIOB->MODER &= ~(0xFFFF); // Limpiar los modos de los primeros 8 pines (pines 0 a 7)
    uint32_t portB_display_masks = (0b01 << 0) | (0b01 << 2) | (0b01 << 4) | (0b01 << 6) |
                                   (0b01 << 8) | (0b01 << 10) | (0b01 << 12) | (0b01 << 14);
    GPIOB->MODER |= portB_display_masks; // Establecer los pines del display como salida

    // Configurar los pines de GPIOB como salida para controlar las columnas de la matriz del teclado
    GPIOB->MODER &= ~((0b11 << 24) | (0b11 << 26) | (0b11 << 28) | (0b11 << 30)); // Limpiar la configuración actual para los pines 12 a 15
    GPIOB->MODER |= ((0b01 << 24) | (0b01 << 26) | (0b01 << 28) | (0b01 << 30)); // Establecer los pines PB12 a PB15 como salidas

    // Configurar los pines del 16 al 22 de GPIOB con resistencias pull-up
    GPIOB->PUPDR &= ~((0b11 << 16) | (0b11 << 18) | (0b11 << 20) | (0b11 << 22)); // Limpiar configuración de pull-up/pull-down
    GPIOB->PUPDR |= ((0b01 << 16) | (0b01 << 18) | (0b01 << 20) | (0b01 << 22)); // Establecer pull-up para pines de entrada

    // Configurar los pines PB8 a PB11 como entrada (teclado matricial)
    GPIOB->MODER &= ~((0b11 << 16) | (0b11 << 18) | (0b11 << 20) | (0b11 << 22)); // Limpiar la configuración actual para los pines 8 a 11




    while (1)
    {

        // Solicitar al usuario que ingrese dos números
            printf("Ingrese el primer número: ");
            scanf("%d", &num1);

            printf("Ingrese el segundo número: ");
            scanf("%d", &num2);

            // Mostrar el menú de operaciones
            printf("\nEscoja una opción:\n");
            printf("1. Suma\n");
            printf("2. Resta\n");
            printf("3. Multiplicación\n");
            printf("4. División\n");

            // Solicitar al usuario que escoja una opción
            printf("Ingrese el número de la opción: ");
            scanf("%d", &opcion);

            // Realizar la operación seleccionada y mostrar el resultado
            switch(opcion) {
                case 1:
                    printf("El resultado de la suma es: %d\n", num1 + num2);
                    break;
                case 2:
                    printf("El resultado de la resta es: %d\n", num1 - num2);
                    break;
                case 3:
                    printf("El resultado de la multiplicación es: %d\n", num1 * num2);
                    break;
                case 4:
                    if (num2 != 0) {
                        printf("El resultado de la división es: %.2f\n", (float)num1 / num2);
                    } else {
                        printf("Error: no se puede dividir por cero.\n");
                    }
                    break;
                default:
                    printf("Opción no válida.\n");
            }

            return 0;




/*

    	 // Leer la operación desde USART2
    	        uint8_t operation[50];
    	        USART2_putstring((uint8_t *)"Ingrese la operacion:\r\n");
    	        USART2_getstring(operation, sizeof(operation));

    	        // Procesar la operación
    	        int result;
    	        if (strstr(operation, "+")) { // Suma
    	            sscanf(operation, "%d+%d", &operand1, &operand2);
    	            result = operand1 + operand2;
    	        } else if (strstr(operation, "-")) { // Resta
    	            sscanf(operation, "%d-%d", &operand1, &operand2);
    	            result = operand1 - operand2;
    	        } else if (strstr(operation, "*")) { // Multiplicación
    	            sscanf(operation, "%d*%d", &operand1, &operand2);
    	            result = operand1 * operand2;
    	        } else if (strstr(operation, "/")) { // División
    	            sscanf(operation, "%d/%d", &operand1, &operand2);
    	            if (operand2 != 0) {
    	                result = operand1 / operand2;
    	            } else {
    	                USART2_putstring((uint8_t *)"Error: Division por cero\r\n");
    	                continue; // Volver a solicitar una nueva operación
    	            }
    	        } else { // Operación no válida
    	            USART2_putstring((uint8_t *)"Error: Operacion no valida\r\n");
    	            continue; // Volver a solicitar una nueva operación
    	        }
*/

        for (int col = 0; col < 4; col++)
        {
            GPIOB->ODR = (0xF << 12); // Desactiva todas las columnas
            GPIOB->ODR &= ~(1 << (12 + col)); // Activa solo la columna actual

            delay_ms(10); // Deja tiempo para la estabilización3a}

            uint32_t rows = GPIOB->IDR & (0xF << 8); // Lee el estado de las filas

            for (int row = 0; row < 4; row++)
            {
                if (!(rows & (1 << (row + 8)))) // Detecta si alguna fila está activa (presionada)
                {
                    uint8_t key_number = col * 4 + row; // Ajusta el cálculo de key_number

                    switch (key_number) {
                        case KEY_F_INDEX:
                            {
                                int sum_value = 0;

                                // Unidades
                                int u_value = get_number_from_key(first_digit_display);
                                // Decenas
                                int d_value = get_number_from_key(second_digit_display);
                                // Centenas
                                int c_value = get_number_from_key(third_digit_display);
                                // Millares
                                //uint8_t m_value = get_number_from_key(fourth_digit_display);

                                sum_value = u_value + (d_value * 10) + (c_value * 100);

                                stored_value = (uint8_t)(stored_value + sum_value);

                                //stored_value = 1;
                                // Borra los displays
                                first_digit_display = second_digit_display = third_digit_display = fourth_digit_display = 0xff;
                            }
                            break;

                        case KEY_A_INDEX:
                            {
                                // Llama a la función para decodificar el valor almacenado en los displays
                                if (stored_value != 0)
                                {
                                    int sum_value = 0;

                                    // Unidades
                                    int u_value = get_number_from_key(first_digit_display);
                                    // Decenas
                                    int d_value = get_number_from_key(second_digit_display);
                                    // Centenas
                                    int c_value = get_number_from_key(third_digit_display);
                                    // Millares
                                    //uint8_t m_value = get_number_from_key(fourth_digit_display);

                                    sum_value =  sum_value +  u_value + (d_value * 10) + (c_value * 100);

                                    stored_value = (uint8_t)(stored_value + sum_value);

                                    u_value = stored_value % 10;
                                    d_value = ((stored_value - u_value) % 100) / 10;
                                    c_value = ((stored_value - d_value - u_value) % 1000) / 100;

                                    first_digit_display =  get_key_from_number(u_value);
                                    second_digit_display = get_key_from_number(d_value);
                                    third_digit_display =  get_key_from_number(c_value);

                                    // Formato para enviar el resultado almacenado
                                    char result_msg[50];
                                    sprintf(result_msg, "Resultado de la suma: %d", stored_value);
                                    USART2_putstring_E((uint8_t *)result_msg);

                                    stored_value = 0;
                                }
                            }
                            break;

                        case KEY_B_INDEX:
                            {
                                // Llama a la función para decodificar el valor almacenado en los displays
                                if (stored_value != 0)
                                {
                                    int res_value = 0;

                                    // Unidades
                                    int u_value = get_number_from_key(first_digit_display);
                                    // Decenas
                                    int d_value = get_number_from_key(second_digit_display);
                                    // Centenas
                                    int c_value = get_number_from_key(third_digit_display);
                                    // Millares
                                    //uint8_t m_value = get_number_from_key(fourth_digit_display);

                                    res_value =  res_value +  u_value + (d_value * 10) + (c_value * 100);

                                    stored_value = (uint8_t)(stored_value - res_value);

                                    u_value = stored_value % 10;
                                    d_value = ((stored_value - u_value) % 100) / 10;
                                    c_value = ((stored_value - d_value - u_value) % 1000) / 100;

                                    first_digit_display =  get_key_from_number(u_value);
                                    second_digit_display = get_key_from_number(d_value);
                                    third_digit_display =  get_key_from_number(c_value);

                                    // Formato para enviar el resultado almacenado
                                    char result_msg[50];
                                    sprintf(result_msg, "Resultado de la resta: %d", stored_value);
                                    USART2_putstring_E((uint8_t *)result_msg);

                                    stored_value = 0;
                                }
                            }
                            break;

                        case KEY_C_INDEX:
                            {
                                if (stored_value != 0)
                                {
                                    int product_value = 0;

                                    // Unidades
                                    int u_value = get_number_from_key(first_digit_display);
                                    // Decenas
                                    int d_value = get_number_from_key(second_digit_display);
                                    // Centenas
                                    int c_value = get_number_from_key(third_digit_display);

                                    int m_value = get_number_from_key(fourth_digit_display);

                                    int input_value = u_value + (d_value * 10) + (c_value * 100) + (m_value * 1000);

                                    product_value = stored_value * input_value;

                                    // Descomponiendo el valor para los displays
                                    u_value = product_value % 10;
                                    d_value = (product_value / 10) % 10;
                                    c_value = (product_value / 100) % 10;
                                    m_value = (product_value / 1000) % 10; // Para el cuarto dígito

                                    first_digit_display = get_key_from_number(u_value);
                                    second_digit_display = get_key_from_number(d_value);
                                    third_digit_display = get_key_from_number(c_value);
                                    // Asume que tienes un cuarto dígito en tu display
                                    fourth_digit_display = get_key_from_number(m_value);

                                    // Formato para enviar el resultado almacenado
                                    char result_msg[50];
                                    sprintf(result_msg, "Resultado multiplicacion: %d", stored_value);
                                    USART2_putstring_E((uint8_t *)result_msg);

                                    stored_value = 0;
                                }
                            }
                            break;

                        case KEY_D_INDEX:
                            {
                                // Verifica si stored_value y el nuevo valor no son cero para evitar división por cero
                                int div_value = 0;
                                int u_value = get_number_from_key(first_digit_display);
                                int d_value = get_number_from_key(second_digit_display);
                                int c_value = get_number_from_key(third_digit_display);

                                div_value = u_value + (d_value * 10) + (c_value * 100);
                                if (stored_value != 0 && div_value != 0) {
                                    stored_value = (uint8_t)(stored_value / div_value);

                                    u_value = stored_value % 10;
                                    d_value = (stored_value / 10) % 10;
                                    c_value = (stored_value / 100) % 10;

                                    first_digit_display = get_key_from_number(u_value);
                                    second_digit_display = get_key_from_number(d_value);
                                    third_digit_display = get_key_from_number(c_value);
                                }

                                // Formato para enviar el resultado almacenado
                                char result_msg[50];
                                sprintf(result_msg, "Resultado de la division: %d", stored_value);
                                USART2_putstring_E((uint8_t *)result_msg);

                                stored_value = 0; // Reset stored_value para evitar acumulación de resultados
                            }
                            break;

                        case KEY_E_INDEX:
                            {
                                // Verifica si stored_value y el nuevo valor no son cero para evitar división por cero
                                stored_value = 0;
                                first_digit_display = second_digit_display = third_digit_display = fourth_digit_display = 0xff;
                                // Reset stored_value para evitar acumulación de resultados
                            }
                            break;

                        default:
                            {
                                fourth_digit_display = third_digit_display;

                                third_digit_display = second_digit_display;
                                // Actualiza el segundo display con el valor del primer display
                                second_digit_display = first_digit_display;
                                // Actualiza el primer display con el nuevo dígito
                                first_digit_display = key_number;
                            }
                            break;
                    }


                    while (!(GPIOB->IDR & (1 << (row + 8)))); // Espera a que la tecla se suelte
                    break; // Sale del bucle de filas para evitar múltiples lecturas
                }
            }
            GPIOB->ODR |= (1 << (12 + col)); // Desactiva la columna actual antes de continuar
        }

        // Actualizar los valores de los displays
        update_display_values();
        stored_value = stored_value %1000;
    }


}



// @16Mhz 3195
// @2.097Mhz 140
void delay_ms(uint16_t n)
{
	uint16_t i;
	for(; n>0; n--)
		for(i=0; i<100; i++ );
}



void update_display_values(void) {


	 if (fourth_digit_display != 0xFF) {
	            GPIOC->BSRR = 1 << (5 + 16); // Apaga el primer dígito
	            GPIOC->BSRR = 1 << (6 + 16); // Apaga el segundo dígito
	            GPIOC->BSRR = 1 << (8 + 16); // Apaga el tercer dígito
	            //	GPIOC->BSRR = 1 << (4 + 16); // Apaga el sexto dígito

	            GPIOC->BSRR = 1 << 9; // Enciende el cuarto dígito

	            GPIOB->BSRR = 0xFF << 16; // Apaga todos los segmentos
	            GPIOB->BSRR = decoder(fourth_digit_display); // Muestra el cuarto dígito
	            delay_ms(5); // Retardo para la visualización
	        }

    if (third_digit_display != 0xFF) {
            GPIOC->BSRR = 1 << (6 + 16); // Apaga el segundo dígito
            GPIOC->BSRR = 1 << (5 + 16); // Apaga el primer dígito
            GPIOC->BSRR = 1 << 8; // Enciende el tercer dígito
            GPIOB->BSRR = 0xFF << 16; // Apaga todos los segmentos
            GPIOB->BSRR = decoder(third_digit_display); // Muestra el tercer dígito
            delay_ms(5); // Retardo para la visualización
    }
    // Multiplexación para mostrar los números en los displays
    if (second_digit_display != 0xFF) {
    	GPIOC->BSRR = 1 << (8 + 16); // Apaga el tercer dígito
        GPIOC->BSRR = 1 << (5 + 16); // Apaga el primer dígito
        GPIOC->BSRR = 1 << 6; // Enciende el segundo dígito
        GPIOB->BSRR = 0xFF << 16; // Apaga todos los segmentos
        GPIOB->BSRR = decoder(second_digit_display); // Muestra el segundo dígito
        delay_ms(5); // Retardo para la visualización
    }

    if (first_digit_display != 0xFF) {
    	GPIOC->BSRR = 1 << (8 + 16); // Apaga el tercer dígito
        GPIOC->BSRR = 1 << (6 + 16); // Apaga el segundo dígito
        GPIOC->BSRR = 1 << 5; // Enciende el primer dígito
        GPIOB->BSRR = 0xFF << 16; // Apaga todos los segmentos
        GPIOB->BSRR = decoder(first_digit_display); // Muestra el primer dígito
        delay_ms(5); // Retardo para la visualización
    }

}

uint8_t decoder(uint8_t number) {
	uint8_t key = 0;
	switch (number){
		case 0: key = 0; break;
		case 1: key = 1; break;
		case 2: key = 2; break;
		case 4: key = 4; break;
		case 5: key = 5; break;
		case 6: key = 6; break;
		case 8: key = 8; break;
		case 9: key = 9; break;
		case 10: key = 10; break;
		case 13: key = 13; break;
		default: return 13;
	}
	return key_to_display[key];
}



void decimal_decoder(uint8_t value) {
    // Verifica si el valor almacenado es un dígito válido (excluyendo A, B, C, D, * y #)
    if (value < 10) {
        // Actualiza los displays con el valor almacenado
    	third_digit_display = second_digit_display;
        second_digit_display = first_digit_display; // Mueve el primer dígito al segundo dígito
        first_digit_display = value; // Establece el primer dígito como el valor almacenado
    }
}


uint8_t USART2_read(void)
{
	while(!(USART2->ISR & 0x0020)){}
	return USART2->RDR;
}

void USART2_write(uint8_t ch)
{
	while(!(USART2->ISR & 0x0080)){}
	USART2->TDR = ch;
}

void USART2_putstring(uint8_t* StringPtr)
{
	while(*StringPtr != 0x00)
	{
		USART2_write(*StringPtr);
		StringPtr++;
	}
}

void USART2_putstring_E(uint8_t* StringPtr)
{
	while(*StringPtr != 0x00)
	{
		USART2_write(*StringPtr);
		StringPtr++;
	}
	USART2_write(0x0D);//CR
	USART2_write(0x0A);//NL
}


void USART2_getstring(uint8_t* buffer, uint32_t max_size) {
    uint32_t count = 0;
    uint8_t received_char;
    while (count < max_size - 1) {
        received_char = USART2_read(); // Leer un carácter desde USART2
        if (received_char == '\r' || received_char == '\n') { // Verificar si se presionó Enter
            break; // Salir del bucle si se presionó Enter
        }
        buffer[count++] = received_char; // Almacenar el carácter en el buffer
    }
    buffer[count] = '\0'; // Agregar el carácter nulo al final de la cadena
}


